# 内存释放机制分析

## 📋 当前实现状态

### ✅ 已实现的内存释放功能

#### 1. **OCR 处理后的图像清理**（第 281-286 行）

```python
finally:
    if img: 
        img.close()          # ✅ 关闭图像对象
    if tmp_path and os.path.exists(tmp_path): 
        os.remove(tmp_path)   # ✅ 删除临时文件
    gc.collect()             # ✅ 垃圾回收
```

**清理内容：**
- ✅ PIL Image 对象关闭
- ✅ 临时文件删除
- ✅ Python 垃圾回收

#### 2. **子进程中的图像清理**（第 123-126 行）

```python
finally:
    if 'img' in locals() and img is not None:
        img.close()          # ✅ 关闭图像对象
    gc.collect()             # ✅ 垃圾回收
```

**清理内容：**
- ✅ 子进程中的图像对象
- ✅ Python 垃圾回收

#### 3. **PDF 处理后的清理**（多处）

- 第 373 行：`gc.collect()`
- 第 417 行：`gc.collect()`
- 第 474 行：`del pix; del img; gc.collect()`
- 第 498 行：`gc.collect()`

---

## ⚠️ 当前设计的限制

### 1. **模型不会在每次 OCR 后释放**

**设计机制：**
- 模型加载后常驻内存（全局变量）
- 每次 OCR 只清理图像和临时数据
- 模型保留在内存中以提高后续请求速度

**代码位置：**
```python
# 第 48-50 行：模型存储在全局变量
_model_instance = None
_processor_instance = None
_model_instance_lock = threading.Lock()
```

**原因：**
- ✅ 性能优化：避免重复加载模型（加载需要 10-20 秒）
- ✅ 快速响应：后续请求无需等待模型加载
- ⚠️ 内存占用：模型占用 ~2-3GB 内存

### 2. **MLX 缓存未在每次 OCR 后清理**

**当前状态：**
- ❌ 没有调用 `mx.clear_cache()` 在每次 OCR 后
- ⚠️ MLX 可能保留中间计算结果

**建议改进：**
```python
finally:
    # ... 现有清理代码 ...
    import mlx.core as mx
    mx.clear_cache()  # 清理 MLX 缓存
    gc.collect()
```

### 3. **子进程结束后模型仍保留**

**设计机制：**
- 子进程结束后，模型对象被删除
- 但主进程中的模型状态不变
- 子进程是独立的，不影响主进程内存

**代码位置：**
```python
# 第 146-149 行：创建独立子进程
process = multiprocessing.Process(
    target=_run_ocr_in_process,
    args=(image_bytes, prompt, max_tokens, output_queue)
)
```

---

## 🎯 当前内存释放设计机制

### 架构图

```
┌─────────────────────────────────────────────────┐
│            Flask 主进程                           │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │  全局模型（常驻内存）                      │  │
│  │  _model_instance                         │  │
│  │  _processor_instance                     │  │
│  │  ~2-3GB 内存                             │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │  OCR 请求处理                            │  │
│  │  1. 创建子进程                           │  │
│  │  2. 传递图像数据                        │  │
│  │  3. 子进程加载模型（如果未加载）         │  │
│  │  4. 执行 OCR                            │  │
│  │  5. 返回结果                            │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │  清理机制（每次 OCR 后）                  │  │
│  │  ✅ 关闭图像对象                         │  │
│  │  ✅ 删除临时文件                         │  │
│  │  ✅ Python 垃圾回收                     │  │
│  │  ❌ 不清理模型（保留）                   │  │
│  │  ❌ 不清理 MLX 缓存（可选）              │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
         │
         │ 创建子进程
         ▼
┌─────────────────────────────────────────────────┐
│           子进程（独立内存空间）                  │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │  子进程模型（独立加载）                    │  │
│  │  _model_instance (子进程内)              │  │
│  │  _processor_instance (子进程内)          │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │  OCR 处理                                │  │
│  │  1. 加载图像                             │  │
│  │  2. 执行推理                             │  │
│  │  3. 返回结果                             │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │  清理机制（子进程结束）                    │  │
│  │  ✅ 关闭图像对象                         │  │
│  │  ✅ Python 垃圾回收                     │  │
│  │  ✅ 进程结束，所有内存自动释放            │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

---

## 📊 内存释放时机

| 时机 | 释放内容 | 是否释放模型 | 代码位置 |
|------|---------|------------|---------|
| **每次 OCR 后** | 图像对象、临时文件 | ❌ 否 | 第 281-286 行 |
| **子进程结束** | 子进程所有内存 | ✅ 是（子进程内） | 第 123-126 行 |
| **手动调用 API** | 模型、缓存 | ✅ 是 | `/api/unload-model` |
| **服务停止** | 所有资源 | ✅ 是 | `cleanup()` 函数 |

---

## 🔧 当前清理机制详细分析

### 1. OCR 请求处理流程

```python
@app.route('/api/ocr', methods=['POST'])
def ocr():
    tmp_path = None
    img = None
    try:
        # 1. 保存文件
        tmp_path = save_file()
        
        # 2. 加载图像
        img = Image.open(tmp_path)
        
        # 3. 执行 OCR（子进程）
        text = generate_with_timeout_and_process(...)
        
        # 4. 返回结果
        return jsonify({'success': True, 'text': text})
    
    finally:
        # ✅ 清理图像对象
        if img: 
            img.close()
        
        # ✅ 删除临时文件
        if tmp_path: 
            os.remove(tmp_path)
        
        # ✅ 垃圾回收
        gc.collect()
        
        # ❌ 未清理：模型（保留在内存）
        # ❌ 未清理：MLX 缓存（可选）
```

### 2. 子进程清理机制

```python
def _run_ocr_in_process(image_bytes, prompt, max_tokens, output_queue):
    try:
        # OCR 处理
        res = generate(...)
        output_queue.put({'success': True, 'text': text})
    finally:
        # ✅ 清理图像对象
        if 'img' in locals() and img is not None:
            img.close()
        
        # ✅ 垃圾回收
        gc.collect()
        
        # ✅ 进程结束，所有内存自动释放
```

---

## 💡 设计理念

### 为什么模型不立即释放？

1. **性能优先**
   - 模型加载需要 10-20 秒
   - 保留模型可以快速响应后续请求
   - 避免重复加载的开销

2. **使用场景**
   - 通常需要处理多张图片
   - 模型常驻内存更高效
   - 适合 Web API 服务场景

3. **内存权衡**
   - 占用 ~2-3GB 内存
   - 换取快速响应（15-30秒 vs 30-50秒）
   - 对于服务器环境可接受

---

## 🎯 改进建议

### 方案 1：每次 OCR 后清理 MLX 缓存（推荐）

```python
finally:
    if img: 
        img.close()
    if tmp_path: 
        os.remove(tmp_path)
    
    # ✅ 新增：清理 MLX 缓存
    import mlx.core as mx
    mx.clear_cache()
    
    gc.collect()
```

**优点：**
- ✅ 清理中间计算结果
- ✅ 不影响模型本身
- ✅ 释放部分内存

**缺点：**
- ⚠️ 可能略微影响性能（缓存重建）

### 方案 2：可选的内存释放模式

添加配置选项：

```python
# 配置
AUTO_RELEASE_MODEL = False  # 是否每次 OCR 后释放模型

if AUTO_RELEASE_MODEL:
    # 释放模型
    unload_model()
```

### 方案 3：基于时间的自动释放

```python
# 如果 30 分钟未使用，自动释放模型
last_used_time = time.time()

def auto_release_if_idle():
    if time.time() - last_used_time > 1800:  # 30 分钟
        unload_model()
```

---

## 📝 总结

### ✅ 当前已实现

1. ✅ **图像对象清理**：每次 OCR 后立即释放
2. ✅ **临时文件清理**：每次 OCR 后立即删除
3. ✅ **Python 垃圾回收**：每次 OCR 后执行
4. ✅ **子进程内存释放**：子进程结束自动释放
5. ✅ **手动释放 API**：`/api/unload-model`

### ⚠️ 当前未实现

1. ❌ **MLX 缓存清理**：每次 OCR 后未清理
2. ❌ **模型自动释放**：模型常驻内存（设计如此）

### 🎯 设计机制

- **模型**：常驻内存（性能优化）
- **图像数据**：立即释放（每次 OCR 后）
- **临时文件**：立即删除（每次 OCR 后）
- **MLX 缓存**：未清理（可改进）

### 💡 建议

1. ✅ **保持当前设计**：模型常驻内存是合理的
2. ✅ **添加 MLX 缓存清理**：在 `finally` 块中添加 `mx.clear_cache()`
3. ✅ **提供配置选项**：允许用户选择是否自动释放模型

